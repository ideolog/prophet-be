from django.db import models
from django.utils.text import slugify
from django.utils.timezone import now
from django.db.models.signals import pre_save
from django.dispatch import receiver
from django.core.exceptions import ValidationError
from django.utils.crypto import get_random_string
from decimal import Decimal

class Claim(models.Model):
    text = models.TextField(help_text="The text of the claim submitted by the user.", unique=True)
    slug = models.SlugField(unique=True, blank=True, max_length=150, help_text="URL-friendly identifier.")
    verification_status = models.ForeignKey(
        'narratives.VerificationStatus',
        on_delete=models.PROTECT,
        related_name="claims"
    )
    status_description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Fields to track the original user and AI-generated claims
    author = models.CharField(max_length=255, help_text="Wallet address of the original user.")
    parent_claim = models.ForeignKey('self', null=True, blank=True, on_delete=models.CASCADE, related_name="ai_variants")
    generated_by_ai = models.BooleanField(default=False, help_text="Indicates if this claim was generated by AI.")
    ai_model = models.CharField(max_length=50, blank=True, null=True, help_text="AI model used for refinement.")

    def save(self, *args, **kwargs):
        if not self.slug:
            base_slug = slugify(self.text)[:150]  # Limit slug length
            unique_slug = base_slug

            # Ensure the slug is unique
            while Claim.objects.filter(slug=unique_slug).exists():
                unique_slug = f"{base_slug}-{get_random_string(5)}"  # Add random suffix to avoid collision

            self.slug = unique_slug

        super().save(*args, **kwargs)

    def __str__(self):
        return self.text[:50]

class UserAccount(models.Model):
    wallet_address = models.CharField(max_length=255, unique=True, help_text="Solana wallet address")
    verification_status = models.ForeignKey(
        'narratives.VerificationStatus',
        on_delete=models.PROTECT,
        related_name="users",
        help_text="Verification status of the user"
    )
    balance = models.DecimalField(
        max_digits=20, decimal_places=8, default=Decimal('1000.0'),
        help_text="User's balance in SOL tokens"
    )
    created_at = models.DateTimeField(default=now, help_text="Account creation timestamp")
    updated_at = models.DateTimeField(auto_now=True, help_text="Last update timestamp")

    def __str__(self):
        return f"{self.wallet_address} - {self.balance} SOL"


class VerificationStatus(models.Model):
    STATUS_CHOICES = [
        ('unverified', 'Unverified'),
        ('pending_ai_review', 'Pending AI Review'),
        ('market_created', 'Market Created'),
        ('ai_reviewed', 'AI Reviewed'),
        ('user_approved', 'User Approved'),
        ('ai_variants_generated', 'AI Variants Generated'),
        ('validator_review', 'Validator Review'),
        ('approved_for_blockchain', 'Approved for Blockchain'),
        ('published', 'Published'),
        ('rejected', 'Rejected'),
    ]

    name = models.CharField(max_length=50, choices=STATUS_CHOICES, unique=True)
    description = models.TextField(blank=True, help_text="Description of the verification status.")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Verification Status"
        verbose_name_plural = "Verification Statuses"

    def __str__(self):
        return self.get_name_display()


class SchoolOfThoughtType(models.Model):
    # The name of the type (e.g., Theory, Scientific Discipline, Ideology, Religion)
    name = models.CharField(max_length=255, unique=True)

    # Optional description field to explain the type
    description = models.TextField(blank=True, null=True)

    def __str__(self):
        return self.name


class SchoolOfThought(models.Model):
    # Name of the school of thought (e.g., Liberalism, Rationalism, etc.)
    name = models.CharField(max_length=255, unique=True)

    # Description of the school of thought
    description = models.TextField(blank=True, null=True)

    # Link to the SchoolOfThoughtType model to categorize the school
    type = models.ForeignKey(SchoolOfThoughtType, on_delete=models.CASCADE, related_name='schools_of_thought')

    # Optional: Parent relationship for hierarchical classification
    parent_school = models.ForeignKey('self', on_delete=models.CASCADE, blank=True, null=True, related_name='sub_schools')

    # Slug for URL-friendly representation
    slug = models.SlugField(unique=True, blank=True)

    def __str__(self):
        return self.name

@receiver(pre_save, sender=SchoolOfThought)
def create_schoolofthought_slug(sender, instance, *args, **kwargs):
    if not instance.slug:
        base_slug = slugify(instance.name)
        unique_slug = base_slug
        while SchoolOfThought.objects.filter(slug=unique_slug).exists():
            unique_slug = f"{base_slug}-{get_random_string(5)}"
        instance.slug = unique_slug


class Value(models.Model):
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(blank=True, null=True)
    slug = models.SlugField(unique=True, blank=True)

    def __str__(self):
        return self.name


class Narrative(models.Model):
    description = models.TextField()
    slug = models.SlugField(unique=True, blank=True, max_length=1024)
    values = models.ManyToManyField('Value', blank=True, related_name='narratives')

    # Many-to-Many for multiple identities and narratives as subjects/objects
    subject_identities = models.ManyToManyField('Category', blank=True, related_name="subj_identities")
    subject_narratives = models.ManyToManyField('Narrative', blank=True, related_name="subj_narratives")

    object_identities = models.ManyToManyField('Category', blank=True, related_name="obj_identities")
    object_narratives = models.ManyToManyField('Narrative', blank=True, related_name="obj_narratives")

    action = models.ForeignKey('Action', blank=True, null=True, on_delete=models.CASCADE,
                               related_name="action_of_narrative")
    time = models.ForeignKey('ActionTime', blank=True, null=True, on_delete=models.CASCADE)
    modality = models.ForeignKey('Modality', blank=True, null=True, on_delete=models.CASCADE)
    modality_negated = models.BooleanField(default=False)

    def save(self, *args, **kwargs):
        # First, save the object to get an ID
        super().save(*args, **kwargs)

        # Now validate the many-to-many relationships
        if self.subject_identities.exists() and self.subject_narratives.exists():
            raise ValidationError("A Narrative can have either subject_identities or subject_narratives, but not both.")
        if self.object_identities.exists() and self.object_narratives.exists():
            raise ValidationError("A Narrative can have either object_identities or object_narratives, but not both.")

    def __str__(self):
        return f"{self.slug} ({self.modality.name if self.modality else 'no modality'})"


class Prediction(models.Model):
    narrative = models.ForeignKey('Narrative', on_delete=models.CASCADE)
    earliest_start_date = models.DateField(blank=True, null=True)
    latest_start_date = models.DateField(blank=True, null=True)
    earliest_end_date = models.DateField(blank=True, null=True)
    latest_end_date = models.DateField(blank=True, null=True)
    minimum_value = models.FloatField(blank=True, null=True)
    maximum_value = models.FloatField(blank=True, null=True)
   # value_unit = models.CharField(max_length=255, blank=True)

    def clean(self):
        # Ensure that either date prediction or value prediction is provided, but not both
        date_fields = [self.earliest_start_date, self.latest_start_date, self.earliest_end_date, self.latest_end_date]
        value_fields = [self.minimum_value, self.maximum_value]

        if any(date_fields) and any(value_fields):
            raise ValidationError("A Prediction can have either date predictions or value predictions, but not both.")
        if not any(date_fields) and not any(value_fields):
            raise ValidationError("A Prediction must have either date predictions or value predictions.")

    def save(self, *args, **kwargs):
        self.full_clean()  # Call the clean method before saving
        super().save(*args, **kwargs)

    def __str__(self):
        if self.earliest_start_date and self.latest_end_date:
            return f"{self.narrative.slug} between {self.earliest_start_date} and {self.latest_end_date}"
        elif self.earliest_start_date:
            return f"{self.narrative.slug} after {self.earliest_start_date}"
        elif self.latest_end_date:
            return f"{self.narrative.slug} before {self.latest_end_date}"
        else:
            if self.minimum_value and self.maximum_value:
                return f"{self.narrative.slug} between {self.minimum_value} and {self.maximum_value} {self.value_unit}"
            elif self.minimum_value:
                return f"{self.narrative.slug} greater than {self.minimum_value} {self.value_unit}"
            elif self.maximum_value:
                return f"{self.narrative.slug} less than {self.maximum_value} {self.value_unit}"
            else:
                return f"{self.narrative.slug} with unknown time or value"


class CategoryType(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)

    def __str__(self):
        return self.name


class Category(models.Model):
    name = models.CharField(max_length=255, unique=True)
    values = models.ManyToManyField('Value', blank=True, related_name='categories')
    slug = models.SlugField(unique=True, blank=True)
    parent = models.ForeignKey('self', on_delete=models.CASCADE, blank=True, null=True, related_name='children')

    # Many-to-many relationship for locations
    locations = models.ManyToManyField('self', blank=True, related_name='location_for_categories', symmetrical=False)

    # Many-to-many field to associate persons with categories (for events like presidential terms)
    persons = models.ManyToManyField('self', blank=True, related_name='events_for_persons', symmetrical=False)

    # ForeignKey to categorize the category
    category_type = models.ForeignKey(CategoryType, on_delete=models.SET_NULL, null=True, blank=True,
                                      related_name='categories')

    class Meta:
        verbose_name = "Category"
        verbose_name_plural = "Categories"

    def __str__(self):
        return self.name


class Action(models.Model):
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(blank=True)
    verbs = models.ManyToManyField('Verb', blank=True)
    slug = models.SlugField(unique=True, blank=True)

    def __str__(self):
        return self.name

class Epoch(models.Model):
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='epochs')
    start_date = models.DateField()
    end_date = models.DateField(blank=True, null=True)
    class Meta:
        unique_together = ('category', 'start_date', 'end_date')  # Ensure uniqueness
    def __str__(self):
        # Display the name of the category and the epoch date range
        if self.end_date:
            return f"{self.category.name} ({self.start_date} - {self.end_date})"
        return f"{self.category.name} (Starting {self.start_date})"


class RelationType(models.Model):
    name = models.CharField(max_length=255)

    def __str__(self):
        return self.name


class ActionRelation(models.Model):
    action1 = models.ForeignKey('Action', on_delete=models.CASCADE, related_name="action1")
    action2 = models.ForeignKey('Action', on_delete=models.CASCADE, related_name="action2")
    relation = models.ForeignKey('RelationType', on_delete=models.CASCADE)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['action1', 'action2', 'relation'], name='unique_action_relation')
        ]

    def __str__(self):
        return f"{self.action1.name} {self.relation.name} {self.action2.name}"


class Verb(models.Model):
    name = models.CharField(max_length=255)

    def __str__(self):
        return self.name


class ActionTime(models.Model):
    TIME_CHOICES = (
        ('past', 'Past'),
        ('present', 'Present'),
        ('future', 'Future'),
    )
    start_time_choice = models.CharField(max_length=32, choices=TIME_CHOICES, default='past')
    end_time_choice = models.CharField(max_length=32, choices=TIME_CHOICES, default='future')

    def __str__(self):
        return "{}-{}".format(self.start_time_choice, self.end_time_choice)


@receiver(pre_save, sender=Narrative)
def create_narrative_slug(sender, instance, *args, **kwargs):
    if not instance.slug:
        base_slug = slugify(instance.description)
        unique_slug = base_slug
        num = 1
        while Narrative.objects.filter(slug=unique_slug).exists():
            unique_slug = f"{base_slug}-{get_random_string(5)}"
        instance.slug = unique_slug


@receiver(pre_save, sender=Category)
def create_category_slug(sender, instance, *args, **kwargs):
    if not instance.slug:
        base_slug = slugify(instance.name)
        unique_slug = base_slug
        while Category.objects.filter(slug=unique_slug).exists():
            unique_slug = f"{base_slug}-{get_random_string(5)}"
        instance.slug = unique_slug


@receiver(pre_save, sender=Action)
def create_action_slug(sender, instance, *args, **kwargs):
    if not instance.slug:
        base_slug = slugify(instance.name)
        unique_slug = base_slug
        while Action.objects.filter(slug=unique_slug).exists():
            unique_slug = f"{base_slug}-{get_random_string(5)}"
        instance.slug = unique_slug

class Modality(models.Model):
    name = models.CharField(max_length=50, unique=True)  # Examples: "must", "should", "can", "will"
    def __str__(self):
        return self.name

class Market(models.Model):
    claim = models.OneToOneField(Claim, on_delete=models.CASCADE, related_name="market")
    creator = models.CharField(max_length=255, help_text="Wallet address of the market creator.")
    created_at = models.DateTimeField(auto_now_add=True)

    # Blockchain placeholders
    contract_address = models.CharField(
        max_length=255, blank=True, null=True,
        help_text="Future Smart Contract address."
    )
    transaction_hash = models.CharField(
        max_length=255, blank=True, null=True,
        help_text="Blockchain transaction hash."
    )

    # Fixed supply for each side (up to 8 decimal places)
    true_shares_remaining = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal('1000000000.0')
    )
    false_shares_remaining = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal('1000000000.0')
    )

    def current_price_for_side(self, side: str) -> Decimal:
        """
        Returns the *instant* price of 1 share on the specified side,
        based on how many shares have been sold so far.

        price(x) = base_price + slope * x,
        where x is the count of shares already sold.
        """
        base_price = Decimal("0.0001")
        slope = Decimal("0.0000001")
        initial_shares = Decimal("1000000000.0")

        if side == "TRUE":
            current_remaining = self.true_shares_remaining
        else:  # side == "FALSE"
            current_remaining = self.false_shares_remaining

        sold_shares = initial_shares - current_remaining
        x = sold_shares  # already sold
        price = base_price + (slope * x)

        # Return price quantized to 8 decimals
        return price.quantize(Decimal("0.00000001"))

    def cost_to_buy_linear(self, side: str, shares_wanted: Decimal) -> Decimal:
        """
        (Unchanged) total cost for buying 'shares_wanted', integrating from x to x + Δ.
        """
        base_price = Decimal("0.0001")
        slope = Decimal("0.0000001")
        initial_shares = Decimal("1000000000.0")

        if side == "TRUE":
            current_remaining = self.true_shares_remaining
        else:
            current_remaining = self.false_shares_remaining

        sold_shares = initial_shares - current_remaining
        x = sold_shares
        delta = shares_wanted

        cost = base_price * delta + (slope / Decimal("2")) * ((x + delta) ** 2 - x ** 2)
        return cost.quantize(Decimal("0.00000001"))

    def __str__(self):
        return f"Market for {self.claim.text[:50]} by {self.creator}"


class MarketPosition(models.Model):
    SIDE_CHOICES = [
        ("TRUE", "True"),
        ("FALSE", "False")
    ]
    user = models.ForeignKey(UserAccount, on_delete=models.CASCADE)
    market = models.ForeignKey(Market, on_delete=models.CASCADE)
    side = models.CharField(max_length=5, choices=SIDE_CHOICES)

    shares = models.DecimalField(
        max_digits=20, decimal_places=8, default=Decimal('0.0')
    )
    cost_basis = models.DecimalField(
        max_digits=20, decimal_places=8, default=Decimal('0.0')
    )

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['user', 'market'], name='unique_user_market')
        ]

    def __str__(self):
        return f"{self.user.wallet_address} - {self.side} - {self.shares} shares"

